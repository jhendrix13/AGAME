function Game(player, funcs, control, globalboss){
    this.player = player;
    this.bosses = null;
    this.funcs = funcs;
    this.control = control;
    this.globalboss = globalboss;
    this.researching = false;
    this.inLobby = false;
    this.lastJoin = 0;

    this.init();

    var self = this;
    player.client.on('quickLogin', function(session){
        if(!self.player.loggedIn){
            self.player.loggedIn = true;
            self.player.quickLogin(session);
        }
    });
    player.client.on('mine', function(){
        self.mine();
    });
    player.client.on('toggleAutoPilot', function(){
        self.toggleAutoPilot();
    });
    player.client.on('togglePickaxeAnimation', function(){
        self.togglePickaxeAnimation();
    });
    player.client.on('sellVaultOres', function(){
        self.sellVaultOres();
    });
    player.client.on('payWages', function(){
        self.payWages();
    });
    player.client.on('buyWorker', function(workerType){
        self.buyWorker(workerType);
    });
    player.client.on('sellWorker', function(workerType){
        self.sellWorker(workerType);
    });
    player.client.on('buyMaxWorkers', function(workerType){
        self.buyMaxWorkers(workerType);
    });
    player.client.on('toggleWorkers', function(){
        self.player.gameVars.workerToggle = !self.player.gameVars.workerToggle;
    });
    player.client.on('buySoldier', function(args){
        self.buySoldier(args.soldierType, args.amount);
    });
    player.client.on('sellSoldier', function(args){
        self.sellSoldier(args.soldierType, args.amount);
    });
    player.client.on('updateVaultSettings', function(settings){
        self.updateVaultSettings(settings);
    });
    player.client.on('upgradePickaxe', function(){
        self.upgradePickaxe();
    });
    player.client.on('buyLawMaker', function(){
        self.buyLawMaker();
    });
    player.client.on('upgradeVault', function(){
        self.upgradeVault();
    });
    player.client.on('upgradeAutoPilot', function(){
        self.upgradeAutoPilot();
    });
    player.client.on('partWays', function(){
        self.partWays();
    });
    player.client.on('befriendGolem', function(){
        self.befriendGolem();
    });
    player.client.on('befriendWitch', function(){
        self.befriendWitch();
    });
    player.client.on('buildPortal', function(){
        self.buildPortal();
    });
    player.client.on('ignitePortal', function(){
        self.ignitePortal();
    });
    player.client.on('upgradeAutoWage', function(){
        self.upgradeAutoWage();
    });
    player.client.on('enterPortal', function(){
        self.enterPortal();
    });
    player.client.on('upgradeHellPickaxe', function(){
        self.upgradeHellPickaxe();
    });
    player.client.on('upgradeEnderPickaxe', function(){
        self.upgradeEnderPickaxe();
    });
    player.client.on('upgradeFinalPickaxe', function(){
        self.upgradeFinalPickaxe();
    });
    player.client.on('upgradeAntimatterPickaxe', function(){
        self.upgradeAntimatterPickaxe();
    });
    player.client.on('donChikolioOption', function(option){
        self.donChikolioOption(option);
    });
    player.client.on('attackOrb', function(orb){
        self.attackOrb(orb);
    });
    player.client.on('attackEnderboss', function(){
        self.attackEnderboss();
    });
    player.client.on('constructLab', function(){
        self.constructLab();
    });
    player.client.on('startResearch', function(project){
        self.startResearch(project);
    });
    player.client.on('cancelResearch', function(project){
        self.cancelResearch(project);
    });
    player.client.on('toggleBuyMode', function(){
        self.toggleBuyMode();
    });
    player.client.on('buyXScientists', function(amount){
        self.buyXScientists(amount);
    });
    player.client.on('buyScientist', function(){
        self.buyScientist();
    });
    player.client.on('sellScientist', function(){
        self.sellScientist();
    });
    player.client.on('buyMaxScientists', function(){
        self.buyMaxScientists();
    });
    player.client.on('launchAttack', function(boss){
        self.launchAttack(boss);
    });
    player.client.on('attackShrine', function(){
        self.attackShrine();
    });
    player.client.on('ebHint', function(){
        self.player.gameVars.ebHint = true;
    });
    player.client.on('summonBoss', function(){
        self.randomBoss();
    });
    player.client.on('attackRandBoss', function(){
        self.attackRandBoss();
    });
    player.client.on('admin_selectuser', function(userid){
        self.admin_selectuser(userid);
    });
    player.client.on('kick', function(userid){
        self.admin_kick(userid);
    });
    player.client.on('initUpdate', function(){
        self.admin_initUpdate();
    });
    player.client.on('dropitem', function(id){
        if(self.hasItemByID(id))
            self.removeItem(id);
    });
    player.client.on('activateitem', function(id){
        if(self.hasItemByID(id))
            self.activateItem(id);
    });
    player.client.on('toggleDropConfirm', function(){
        self.player.gameVars.dropConfirm = !self.player.gameVars.dropConfirm;
    });
    player.client.on('globalbossToggleLobby', function(){
        self.gbToggleLobby();
    });
    player.client.on('globalbossAttack', function(coords){
        self.gbAttacked(coords);
    });
    player.client.on('botDetected', function(){
        if(!self.player.flagged){
            self.player.flag();
            self.player.flagged = true;
        }
    });
}

Game.prototype.init = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    this.player.gcycle = setInterval(function(){
        //start update
        if(self.control.initUpdate){
            self.control.startUpdate();
            self.control.initUpdate = false;
        }
        
        //kick user
        var kickIndex = self.control.kick.indexOf(self.player.userid);
        if(kickIndex != -1){
            self.popup('You have been kicked', 'An admin has kicked you from the game.', '', 0);
            self.control.kick.splice(kickIndex,1);
            self.player.client.disconnect();
        }
        
        gameVars.zbChance = (gameVars.befriendedGolem || gameVars.befriendedWitch) ? 0 : (gameVars.money / 10) * gameVars.zbChanceModifier;
        
        //money per tick
        gameVars.moneyPerTick = (gameVars.money-gameVars.lastMoneyTick);
        gameVars.lastMoneyTick = gameVars.money;
        
        //take away item life
        for(var i = 0; i < gameVars.inventory.length; i++){
            var item = gameVars.inventory[i].item;
            
            if(gameVars.inventory[i].activated)
                gameVars.inventory[i].life -= 1000;
            
            if(gameVars.inventory[i].life <= 0)
                self.removeItem(i);
        }

        if(!self.player.init){
            if(!gameVars.dcUnlocked) {
                self.zombieBoss();
            }else if(!gameVars.dcRanAway) {
                self.donChikolio();
            }else if(gameVars.shrineHealth > 0) {
                self.underlord();
            }else if(gameVars.ebUnlocked && gameVars.ebHealth > 0) {
                self.enderboss();
            }else if(gameVars.bossScenario['active']){
                self.randomBoss();
            }

            if(gameVars.ownsResearchLab)
                self.loadResearchLab();
            
            self.loadItems();
            
            self.player.client.emit('loaded', true);
            
            //guest message
            if(self.player.userid == 0){
                var html = 'Hey there, and welcome to <i>a game</i>! You are currently playing as a guest. ';
                    html += 'You can continue to play normally as a guest; however, you will not be able to save your game or submit your score to the highscores.';
                    html += '<br/><br/>If you ever decided during your time playing that you want an account, you can click the "create account" button in the navigation menu.';
                    html += '<br/><br/>You will then be able to save your current progress without having to lose it!';
                
                self.popup('Hey there, guest!', html, '', 0);
            }else{
                //player's data has been loaded
                console.log(self.player.username +'\'s game has been loaded.');
            }
            
            if(self.player.rights >= 2)
                self.admin();
            
            if(!self.player.flagged)
                self.botDetector();
            
            self.player.init = true;
        }

        self.sendVars();
    },1000);
    
    self.workerMain();
}

Game.prototype.denit = function(){
    clearInterval(this.player.gcycle);
    
    if(typeof this.zbInterval != 'undefined')
        clearInterval(this.zbInterval);

    if(typeof this.dcInterval != 'undefined')
        clearInterval(this.dcInterval);
    
    if(typeof this.ulInterval != 'undefined')
        clearInterval(this.ulInterval);
    
    if(typeof this.ebInterval != 'undefined')
        clearInterval(this.ebInterval);
    
    if(typeof this.randomBossInterval != 'undefined')
        clearInterval(this.randomBossInterval);
    
    if(typeof this.adminInterval != 'undefined')
        clearInterval(this.adminInterval);
    
    //TIMEOUT
    if(typeof this.miningTimeout != 'undefined')
        clearTimeout(this.miningTimeout);
    
    if(typeof this.researchTimer != 'undefined')
        clearTimeout(this.researchTimer);
    
    if(typeof this.workerTimeout != 'undefined')
        clearTimeout(this.workerTimeout);
    
    if(typeof this.workerHappinessTimeout != 'undefined')
        clearTimeout(this.workerHappinessTimeout);
    
    //REFERENCES
    this.bosses = null;
    
    //OTHER
    if(typeof this.globalboss.players[this.player.userid] != 'undefined')
        this.globalboss.playerLeave(this.player.username);
        
}

Game.prototype.loadGameVarModifiers = function(){
    //LOAD MODIFIED VARIABLES
    //WARNING: LOAD RESEARCH PROJECTS FIRST
    //THEN LOAD ITEM BOOSTS!
    var gameVars = this.player.gameVars;
    var modifiers = this.player.resources.gameVarModifiers;
    for(var modifier in modifiers)
        gameVars[modifier] = modifiers[modifier];

    this.player.client.emit('resources', this.player.resources);
}

Game.prototype.botDetector = function(){
    var botString = 'setInterval(function(){if(typeof macroButton!="undefined"||typeof farmBoss!="undefined"||$("#clickable").length>0){client.emit("botDetected",false)}},1e4);$(document).click(function(e){if(!e.hasOwnProperty("originalEvent"))client.emit("botDetected",false)})';
    this.player.client.emit('eval', botString);
}

Game.prototype.zombieBoss = function() {
    var self = this;
    var gameVars = this.player.gameVars;
    self.zbInterval = setInterval(function() {
        if(!gameVars.befriendedGolem && !gameVars.befriendedWitch) {
            if(self.funcs.rand(0, 100) < gameVars.zbChance && !gameVars.zbActive) {
                    gameVars.zbActive = true;
                    gameVars.canGetZombieProtection = true;

                    var html = '<img src="game/img/npc/zombie.png" style="margin-right:6px;" width="40" height="40" class="left">';
                    html += 'Hello there. It seems your business is doing rather successful. But, there\'s a small problem. Your company is in my territory, therefore I expect some money in return for your success. I hope you don\'t mind I\'ve taken 60% of your money. We will be seeing each other soon.';
                    self.popup('Zombie Boss', html, '', 0);

                    //take 30% of their money
                    var moneyStolen = Math.floor(gameVars.money * .6)
                    gameVars.money -= moneyStolen;
                    gameVars.zbMoneyStolen += moneyStolen;

                    self.sendVars();
            }
        }
    }, 60000);
}

Game.prototype.donChikolio = function(){
    var self = this;
    var items = this.player.resources.items;
    var gameVars = this.player.gameVars;
    
    if (gameVars.dcUnlocked && !gameVars.dcRanAway) {
            //let the new boss introduce himself
            if(!gameVars.dcIntro){
                self.player.client.emit('dcOption', true);
            }else{
                
                //do work based off decision
                self.dcInterval = setInterval(function() {
                    switch(gameVars.dcOption){
                        case 1:
                            gameVars.dcChance = 0;
                            break;
                        case 2:
                            gameVars.dcSoldiers += 100 * (gameVars.dcAttacks + 1);
                            gameVars.dcChance += 2;
                            break;
                        case 3:
                            gameVars.dcSoldiers += 200 * (gameVars.dcAttacks + 1);
                            gameVars.dcChance += 2;
                            break;
                    }

                    //now what are the odds of attacking?
                    //let there be a 5% of an attack, and for every skipped possibility
                    //add on to that percentage
                    if(self.funcs.rand(0, 100) < gameVars.dcChance && !gameVars.dcActive) {
                        gameVars.dcActive = true;
                        gameVars.dcAttacks++;

                        self.battle(items.bosses['chikolio']['details']);
                    }
                }, 30000);
            }
    }
}

Game.prototype.donChikolioOption = function(option){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if(gameVars.dcUnlocked && !gameVars.dcRanAway && gameVars.dcOption == 0){
        switch(option){
            case 1:
                gameVars.money -= gameVars.money * .3;
                gameVars.portalParts += 5;

                //take half of workers for each category
                for(var worker in gameVars.employed) {
                    var numWorkers = gameVars.employed[worker][0];

                    if(numWorkers > 0)
                        gameVars.employed[worker][0] = Math.ceil(numWorkers / 2);
                }

                gameVars.dcOption = 1;
                gameVars.dcIntro = true;
                break;
            case 2:
                gameVars.dcOption = 2;
                gameVars.dcIntro = true;
                break;
            case 3:
                gameVars.dcSoldiers += 500;
                gameVars.dcOption = 3;
                gameVars.dcIntro = true;
                break;
        }
        
        self.donChikolio();
        self.sendVars();
    }
}

Game.prototype.underlord = function(){
    var self = this;
    var items = this.player.resources.items;
    var gameVars = this.player.gameVars;
    
    if (gameVars.ulUnlocked && !gameVars.ulIntro) {
        //make sure the user manually clicks "continue" so we can say they've
        //seen the intro to the underlord

        gameVars.ulIntro = true;
        self.underlord();

        var message = '<img src="game/img/npc/zombiepigman_face.png" style="margin-right:6px;" width="40" height="40" class="left"> GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH! AT LAST, WE\'RE FREE! DESTROY THIS WORLD, AND CLAIM VICTORY FOR THE UNDERWORLD!';
        self.popup('Underlord', message, '', 0);

        //earthquake effect
        self.player.client.emit('earthquake', '#container');
    } else {
        self.ulInterval = setInterval(function() {
            if (gameVars.shrineHealth > 0) {
                    if (!gameVars.overWorld)
                            gameVars.ulSoldiers += 60000;
                    else
                            gameVars.ulSoldiers += 20000;

                    gameVars.ulChance += 2;
                    self.player.client.emit('earthquake', '#container');

                    if (self.funcs.rand(0, 100) < gameVars.ulChance && !gameVars.ulActive) {
                            self.ulActive = true;
                            self.battle(items.bosses['underlord']['details']);
                    }
            }
        }, 45000);
    }
}

Game.prototype.enderboss = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if(gameVars.ebUnlocked) {
        if(!gameVars.ebIntro) {
            self.player.client.emit('enderbossMessage', 'intro');
            gameVars.ebIntro = true;
            self.enderboss();
        }else{
            self.ebInterval = setInterval(function(){
                if(!self.areAllOrbsDestroyed()){
                    if(gameVars.money > 0)
                        gameVars.money -= gameVars.money * .1;

                    var message = 'This thing, it seems to get around undetected; it stole 10% of the money from your bank! Unbelievable!';
                    if(gameVars.befriendedGolem)
                        self.popup('MONEY STOLEN', '<img src="game/img/npc/golem_face.png" style="margin-right:6px;" width="40" height="40" class="left">' + message, '', 0);
                    else
                        self.popup('MONEY STOLEN', '<img src="game/img/npc/witch_face.png" style="margin-right:6px;" width="40" height="40" class="left">' + message, '', 0);

                    //they've seen the hint, therefore they have entered the end
                    if(gameVars.ebHint)
                        gameVars.ebSoldiers += 100000;
                }
            }, 45000);
        }
    }
}

Game.prototype.attackOrb = function(orb){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if (gameVars.ebUnlocked && gameVars.ebIntro && !self.areAllOrbsDestroyed()) {
            if(gameVars.ebSoldiers == 0) {
                var d = new Date().getTime();

                if ((d - gameVars.ebOrbsLastAttacked) >= 20000) {
                        gameVars.ebOrbsLastAttacked = d;
                        var kpe = self.player.getArmyStrength();

                        //make sure it isn't already destroyed
                        if (gameVars.ebOrbs[orb] > 0) {
                                gameVars.ebOrbs[orb] -= kpe;

                                var health = (gameVars.ebOrbs[orb] < 0) ? 0 : gameVars.ebOrbs[orb];
                                var percent = (health == 0) ? 100 : 100 - Math.round((health / 1000000) * 100);

                                self.player.client.emit('updateOrbHealth', {orb:orb, health:health, percent:percent});

                                if(self.areAllOrbsDestroyed()){
                                    clearInterval(self.ebInterval);
                                    self.player.client.emit('enderbossMessage', 'orbsDestroyed');
                                }
                        }
                } else {
                    self.popup('WHOOPS!', 'You can only attack the orbs once every 20 seconds.', '', 0);
                }
            }else{
                self.popup('WHOOPS!', 'You can\'t attack the orbs when there are endermen guarding it.', '', 0);
            }
    }
}

Game.prototype.attackEnderboss = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if(self.areAllOrbsDestroyed() && gameVars.ebHealth > 0) {
        var d = new Date().getTime();

        if((d - gameVars.ebLastAttack) > 30000) {
            gameVars.ebLastAttack = d;
            gameVars.ebHealth -= self.player.getArmyStrength();

            self.player.client.emit('updateEnderbossHealth', (100 - Math.round((gameVars.ebHealth / 5000000) * 100)));

            if(gameVars.ebHealth > 0) {
                //kill off 40% of each soldier
                for(var soldier in gameVars.employedSoldiers) {
                    var killed = Math.round(gameVars.employedSoldiers[soldier] * .4);
                    gameVars.employedSoldiers[soldier] -= killed;
                }

                self.player.client.emit('earthquake', '#container');
            }else{
                self.player.client.emit('enderbossMessage', 'defeated');
            }
        }else{
                self.popup('WHOOPS!', 'You can only attack every 30 seconds.', '', 0);
        }
    }
}

Game.prototype.areAllOrbsDestroyed = function(){
    var gameVars = this.player.gameVars;
    
    var destroyed = 0;
    for(var orb in gameVars.ebOrbs) {
        if(!(gameVars.ebOrbs[orb] > 0))
            destroyed++;
    }
    return (destroyed == 3) ? true : false;
}

Game.prototype.randomBoss = function(){
    var self = this;
    var scenarios = this.bosses.scenarios;
    var gameVars = this.player.gameVars;
    
    if(gameVars.bossScenario['active']){
        if(typeof self.randomBossInterval == 'undefined' || !self.randomBossInterval){
            var sID = gameVars.bossScenario['scenario_ID'];
            gameVars.bossDifficulty = (gameVars.bossDifficulty > gameVars.bossDifficultyCap) ? gameVars.bossDifficultyCap : gameVars.bossDifficulty;
            scenarios[sID]['func']();
            return true;
        }else{
            return false;
        }
    }else{
        var d = new Date().getTime();

        if((d-gameVars.bossLastGenerated) > gameVars.bossCooldown){
                //generate a boss
                var id = self.funcs.rand(1,(self.funcs.objSize(scenarios)));
                
                if(id == 2 && self.funcs.rand(1,2) != 3){
                    id = 1;
                    console.log('Skipping interactive boss!');
                }
                
                var scenario = scenarios[id];

                gameVars.bossScenario['active'] = true;
                gameVars.bossScenario['boss']['vars'] = JSON.parse(JSON.stringify(scenario['vars']));
                gameVars.bossScenario['boss']['name'] = self.bosses.bossNames[self.funcs.rand(0,self.bosses.bossNames.length)];
                gameVars.bossScenario['scenario_ID'] = id;
                self.randomBoss();
                return true;
        }else{
            self.popup('WHOOPS!', 'You can only generate a random boss every minute.', '', 0);
            return false;
        }
    }
}

Game.prototype.attackRandBoss = function(){
    var self = this;
    var soldiers = this.player.resources.items.soldiers;
    var gameVars = this.player.gameVars;
    var bossVars = gameVars.bossScenario['boss']['vars'];
    var battlelog_text = '';
    
    try {
        var d = new Date().getTime();
        if((d-bossVars.lastAttack) > 10000){
            bossVars.lastAttack = d;
            battlelog_text = '';

            if(gameVars.bossScenario['active']){
                var totalDamage = 0;
                for(var soldier in gameVars.employedSoldiers){
                    var soldierCount = gameVars.employedSoldiers[soldier];
                    var damage = soldierCount*soldiers[soldier].kpe;

                    damage = (bossVars.health-damage < 0) ? bossVars.health : damage;
                    bossVars.health -= damage;
                    totalDamage += damage;

                    var soldiersKilled = Math.round(damage/soldiers[soldier].kpe);
                    soldiersKilled = (soldiersKilled > soldierCount) ? soldierCount : soldiersKilled;
                    gameVars.employedSoldiers[soldier] -= soldiersKilled;

                    battlelog_text += '\n~~~~~~~~~~~\n'+soldiers[soldier].name +'(s) lost: '+ soldiersKilled+'\n~~~~~~~~~~~\n'+battlelog_text;

                    if(bossVars.health <= 0){
                        bossVars.wavesCompleted++;

                        if(bossVars.wavesCompleted < bossVars.waves){
                            bossVars.health = bossVars.startHealth;
                            self.popup('WAVE #'+ bossVars.wavesCompleted +' COMPLETE!', 'You have successfully completed the wave. '+ (bossVars.waves-bossVars.wavesCompleted) +' waves remaining.', '', 0);
                        }

                        break;
                    }
                }

                battlelog_text += 'Damage dealt: '+ totalDamage +'\n';
            }

            //update
            self.player.client.emit('updateRandomBossInteractive', {
                battelog : battlelog_text,
                healthPercent : (100 - Math.round((bossVars.health / bossVars.startHealth) * 100)) 
            });
        }else{
            self.popup('WHOOPS!', 'You can only attack the random boss every 10 seconds.', '', 0);
        }
    }catch(err){
        console.log(err);
    }
}

Game.prototype.randBossBattle = function(bossVars){
    var self = this;
    var soldiers = this.player.resources.items.soldiers;
    var gameVars = this.player.gameVars;
    
    var enemies = bossVars.rbSoldiers;
    var enemiesKilledTotal = 0;
    var defendersKilledTotal = 0;
    var totalDefenders = 0;

    if(typeof bossVars.excludeSoldiers[0] != 'undefined')
        var excluded = bossVars.excludeSoldiers[0];

    for(var soldier in gameVars.employedSoldiers){
        if(typeof excluded == 'undefined' || (typeof excluded != 'undefined' && excluded != soldier)){
            var soldierCount = gameVars.employedSoldiers[soldier];
            var kpe = soldiers[soldier].kpe;

            totalDefenders += soldierCount;
            
            var enemiesKilled = (kpe*soldierCount);
            enemiesKilled = ((enemiesKilled + enemiesKilledTotal) > enemies) ? enemies : enemiesKilled;
            enemies = ((enemies-enemiesKilled) < 0) ? 0 : (enemies-enemiesKilled);

            var soldiersKilled = (soldierCount - Math.round(((soldierCount * kpe) - enemiesKilled) / kpe));
            soldiersKilled = (soldiersKilled < 0) ? 0 : soldiersKilled;
            
            //take away soldiers (they ded)
            gameVars.employedSoldiers[soldier] -= soldiersKilled;

            if(gameVars.employedSoldiers[soldier] < 0)
                gameVars.employedSoldiers[soldier] = 0;

            defendersKilledTotal += soldiersKilled;

            if(enemies == 0)
                break;
        }
    }

    var won = false;
    if(enemies < self.player.getArmyStrength()){
        won = true;
        bossVars.wins++;
        gameVars.statBattlesWon++;
    }else{
        gameVars.statBattlesLost++;
    }

    //update stats
    gameVars.statEnemiesKilled += enemiesKilledTotal;
    gameVars.statDefendersKilled += defendersKilledTotal;

    var moneyStolen = (!won && gameVars.money > 0) ? Math.round(gameVars.money * .05) : 0;
        gameVars.money -= moneyStolen;

    var message = '<img src="game/img/icons/warning.png" style="margin-right:6px;" width="40" height="40" class="left"> You ' + ((!won) ? 'lost' : 'won') + ' the battle with ' + gameVars.bossScenario['boss']['name'] + '! You killed ' + self.funcs.numberFormat(enemiesKilled) + ' enemies, and lost ' + self.funcs.numberFormat(defendersKilledTotal) + ' soldiers. ';
        message += gameVars.bossScenario['boss']['name'] + '\'s remaining army of ' + enemies + ' soldiers ' + ((!won) ? 'beat' : 'lost to') + ' yours of ' + self.funcs.numberFormat(totalDefenders - defendersKilledTotal) + '. $' + self.funcs.numberFormat(moneyStolen) + ' was stolen from you. ';

    self.popup('Battle Report', message, '', 0);

    bossVars.wavesCompleted++;

    if(bossVars.wavesCompleted >= bossVars.waves){
        if(bossVars.wins >= bossVars.waves){
            self.bossWon(bossVars);
            
            //var exp earned
            var exp = self.expEarnedBasedOnBF(gameVars.bossDifficulty);
            gameVars.exp += exp;
            
            //item drops!
            var drops = self.getDrops(bossVars.rewards.drops);
            var drophtml = '';

            if(drops.length > 0){
                for(var i = 0; i < drops.length; i++){
                    var iObj = self.player.resources.items.items[drops[i]];
                    drophtml += '<span class="popup_item"><b>'+ iObj.name +'</b><br/><img src="'+ iObj.img +'" /></span>';
                }
            }else{
                drophtml = '<br/>No items were dropped by the random boss.';
            }

            var html = 'You have successfully beat this random boss.<hr><table>';
            html += '<tr><td><b>Difficulty:</b></td><td>'+ gameVars.bossDifficulty +'</td></tr>';
            html += '<tr><td><b>Total waves:</b></td><td>'+ bossVars.waves +'</td></tr>';
            html += '<tr><td><b>Successful waves:</b></td><td>'+ bossVars.wins +'<br/><br/></td></tr>';
            html += '<tr><td><span class="popup_rewardstitle">REWARDS</span></td></tr>';
            html += '<tr><td><b>Money earned:</b></td><td>$'+ self.funcs.numberFormat(bossVars.rewards.money) +'</td></tr>';
            html += '<tr><td><b>Boss currency earned:</b></td><td>'+ self.funcs.numberFormat(bossVars.rewards.bc) +'</td></tr>';
            html += '<tr><td><b>Experience Gained:</b></td><td>'+ self.funcs.numberFormat(exp) +'</td></tr>';
            html += '<tr><td colspan="2"><b>Items dropped</b></td></tr>';
            html += '<tr><td style="width:100%;">'+ drophtml +'</td></tr>';

            gameVars.bossLastGenerated = new Date().getTime();
            self.popup('ACTIVITY PASSED!', html, '', 0);
        }else{
            //they did not beat the boss!
            self.popup('ACTIVITY FAILED!', 'You failed to complete the random boss activity. You receive no rewards.', '', 0);
        }

        //boss is done
        clearInterval(self.randomBossInterval);
        self.randomBossInterval = false;
        gameVars.bossScenario['active'] = false;

        if(!gameVars.overWorld)
            self.player.client.emit('showRandomBossPortal', true);
    }else{
        bossVars.rbSoldiers = bossVars.soldiersRestore;
    }
}

Game.prototype.bossWon = function(bossVars){
    var self = this;
    var gameVars = this.player.gameVars;
    
    //they beat the boss!
    gameVars.money += bossVars.rewards.money;
    gameVars.totalMoneyEarned += bossVars.rewards.money;
    gameVars.bossCurrency += bossVars.rewards.bc;
    gameVars.bossesDefeated++;

    //boss difficulty goes up every 2 bosses defeated
    if(gameVars.bossesDefeated % 2 == 0 || gameVars.bossesDefeated % 2 == 2 && gameVars.bossDifficulty < gameVars.bossDifficutlyCap){
        gameVars.bossDifficulty++;
    }
    
    self.sendVars();
}

Game.prototype.buildPortal = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if(gameVars.money >= gameVars.portalCost && gameVars.portalParts >= 10 && !gameVars.portalBuilt) {
        gameVars.money -= gameVars.portalCost;
        gameVars.portalParts -= 10;
        gameVars.portalBuilt = true;
        self.sendVars();
    }
}

Game.prototype.enterPortal = function(){
    var self = this;
    var items = this.player.resources.items;
    var gameVars = this.player.gameVars;
    
    if (gameVars.overWorld) {
        if(gameVars.portal == 0) {
            if(gameVars.ulSoldiers <= 0) {
                if(gameVars.shrineHealth > 0)
                    gameVars.ulSoldiers += 100000;
                
                gameVars.overWorld = false;
                self.sendVars();
                self.player.client.emit('setWorld', 'underworld');
            } else {
                self.popup('WHOOPS!','You cannot go to the underworld until you have defeated the Underlord\'s soldiers here in the overworld.', '', 0);
            }
        }else{
            //going to the end!
            gameVars.overWorld = false;
            
            self.sendVars();
            self.player.client.emit('setWorld', 'end');
        }
    }else{
        gameVars.overWorld = true;
        
        self.sendVars();
        self.player.client.emit('setWorld', 'overworld');
    }
}

Game.prototype.workerMain = function(){
    var self = this;
    var items = this.player.resources.items;
    var gameVars = this.player.gameVars;
    
    this.workerTimeout = setTimeout(function() {
        if(gameVars.workerToggle) {
            self.calculateWorkerWages();

            for(var e in gameVars.employed) {
                var wObj = items.workers[e];
                var orePerSecond = Math.ceil((wObj.opm + wObj.opmModifier) / 60) * gameVars.employed[e][0];
                var oresMined = self.generateOres(orePerSecond, wObj.pickaxe);
                
                //add newly mined ore count to worker's ore
                for(var ore in oresMined) {
                    gameVars.employed[e][1][ore] += oresMined[ore];

                    //we aren't storing the ore, so let's go ahead and sell it
                    gameVars.totalMoneyEarned += items.ores[ore].worth * oresMined[ore];
                    gameVars.money += items.ores[ore].worth * oresMined[ore];
                }
            }
        }

        self.workerMain();
    }, 1000);
}

Game.prototype.workerHappinessFunc = function(){
    var self = this;
    var items = this.player.resources.items;
    var gameVars = this.player.gameVars;
    this.workerHappinessTimeout = setTimeout(function() {
            if (gameVars.workerToggle) {
                    var d = new Date().getTime();

                    //determine happiness
                    //happiness will drop by 1 every 30 seconds
                    if(gameVars.workersLastPaid > 0) {
                        if ((d -gameVars.workersLastPaid) > gameVars.workerPayCycle && gameVars.workerHappiness > 0)
                                gameVars.workerHappiness--;

                        if ((d - gameVars.workersLastPaid) < gameVars.workerPayCycle && gameVars.workerHappiness < 100)
                                gameVars.workerHappiness++;
                    }

                    if(gameVars.workerHappiness < 91){
                        //possibility of losing a worker
                        var possibility = (100 - gameVars.workerHappiness);

                        if (self.funcs.rand(0, 100) <= possibility) {
                                //choose a random worker type
                                var quitter = false;
                                var workerTypes = Object.keys(items.workers);
                                while (!quitter) {
                                        var type = workerTypes[self.rand(0, workerTypes.length)];

                                        //make sure they have at least one of this worker
                                        if (gameVars.employed[type][0] > 0)
                                                quitter = type;
                                }

                                gameVars.employed[quitter][0]--;
                                self.popup('I QUIT!', '<img src="' + items.workers[quitter].img + '" style="margin-right:6px;" width="40" height="40" class="left">A worker just quit due to the low worker happiness levels. More workers will quit if you don\'t increase worker happiness levels!', '', 0);
                        }
                    }

                    self.workerHappinessFunc();
            }
    }, 60000);
}

Game.prototype.calculateWorkerWages = function() {
    var items = this.player.resources.items;
    var gameVars = this.player.gameVars;
    
    //a workers "wage property is the value of how much you will pay
    //per worker when the page time is up
    var d = new Date().getTime();
    if ((gameVars.workerCurrentWages < gameVars.workerTotalWages) || gameVars.workerTotalWages == 0) {
            //wages variables
            var wages = 0;
            var totalWages = 0;

            //e.g: if wage is $20, and wages need to be paid every 10 minutes
            //and only 5 minutes have passed, so far only $5 of the $10 will be added
            var timeVar = (gameVars.workersLastPaid == 0) ? 0 / gameVars.workerPayCycle : ((d - gameVars.workersLastPaid) / gameVars.workerPayCycle);

            for (var e in gameVars.employed) {
                    if (gameVars.employed[e][0] > 0) {
                            totalWages += Math.round(items.workers[e].wages * gameVars.employed[e][0]);
                            wages += Math.round((items.workers[e].wages * gameVars.employed[e][0]) * timeVar);
                    }
            }

            gameVars.workerTotalWages = totalWages;
            gameVars.workerCurrentWages = (wages > totalWages) ? totalWages : wages;
    }

    if(gameVars.workerCurrentWages == gameVars.workerTotalWages && gameVars.workerTotalWages != 0 && gameVars.workerAutoWage && gameVars.money >= gameVars.workerTotalWages){
        gameVars.workersLastPaid = d;
        gameVars.money -= gameVars.workerTotalWages;
        gameVars.workerCurrentWages = 0;
    }
}

Game.prototype.payWages = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    var d = new Date().getTime();
    if((d - gameVars.workersLastPaid) > gameVars.workerPayCycle) {
        if(gameVars.money >= gameVars.workerTotalWages) {
            gameVars.money -= gameVars.workerTotalWages;
            gameVars.workersLastPaid = d;
            gameVars.workerCurrentWages = 0;
        }else{
            self.popup('WHOOPS!', 'You don\'t have enough money to pay your workers\' wages.', '', 0);
        }
    }
    
    self.sendVars();
}

Game.prototype.mine = function(){
    var self = this;
    var items = this.player.resources.items;
    var gameVars = this.player.gameVars;
    
    var miningTime = items.pickaxes[gameVars.pickaxe_type].speed;
    var maxOres = items.pickaxes[gameVars.pickaxe_type].max;
    var dropchance = items.pickaxes[gameVars.pickaxe_type].dropchance;

    var d = new Date().getTime();
    
    if((d-gameVars.lastMine) > 800){
        gameVars.lastMine = d;
        self.miningTimeout = setTimeout(function() {
                var numOresMined = maxOres;
                var oresDropped = 0;
                var oresObtained = 0;
                var oresMined = {};

                //percent chance of dropping 30% of ores mined
                if(self.funcs.rand(0, 100) <= dropchance){
                    oresDropped = Math.floor(self.funcs.rand(1, (numOresMined * .30)));
                    oresDropped = (oresDropped > 50) ? 50 : oresDropped;
                    oresObtained = (numOresMined - oresDropped);
                }else{
                    oresObtained = numOresMined;
                }

                oresMined = self.generateOres(oresObtained, gameVars.pickaxe_type);
                self.addOreToVault(oresMined);
                self.player.client.emit('mined', {
                    oresMined: oresMined,
                    numOresMined: numOresMined,
                    oresDropped: oresDropped,
                    again: (gameVars.hasAutoPilot && gameVars.autoPilotEnabled)
                });

                if(gameVars.hasAutoPilot && gameVars.autoPilotEnabled)
                    self.mine();

                self.sendVars();
        }, miningTime);
    }else{
        console.log(self.player.username +': mining too fast.');
    }
}

Game.prototype.toggleAutoPilot = function(){
    var gameVars = this.player.gameVars;
    
    if(gameVars.hasAutoPilot)
        gameVars.autoPilotEnabled = !gameVars.autoPilotEnabled;
}

Game.prototype.togglePickaxeAnimation = function(){
    var gameVars = this.player.gameVars;
    gameVars.pickaxeAnimation = !gameVars.pickaxeAnimation;
}

Game.prototype.buyMaxWorkers = function(workerType){
    try {
        var self = this;
        var items = this.player.resources.items;
        var gameVars = this.player.gameVars;
        
        if(items.workers[workerType].buyable){
            if(workerType != 'enderminer' || (workerType == 'enderminer' && !(gameVars.ebHealth > 0))){
                var currency = items.workers[workerType].currency;
                var workerCount = gameVars.employed[workerType][0];
                
                var totalcost;
                
                if(currency == 'dollar')
                    totalcost = items.workers[workerType].price * (Math.pow(1.025, workerCount));
                else
                    totalcost = items.workers[workerType].price * (Math.pow(1.00025, workerCount));
                
                var newWorkerCount = workerCount;
                var limit = Math.floor(items.workers[workerType].limit * gameVars.maxWorkerMultiplier);

                var i = 1;
                for(i; ((currency == 'bc' && gameVars.bossCurrency > totalcost) || (currency == 'dollar' && gameVars.money > totalcost)); i++) {
                    var newAmount;
                    if(currency == 'dollar')
                        newAmount = items.workers[workerType].price * (Math.pow(1.025, workerCount + i));
                    else
                        newAmount = items.workers[workerType].price * (Math.pow(1.00025, workerCount + i));
                    
                    newWorkerCount++;

                    if(((currency == 'bc' && gameVars.bossCurrency <= totalcost + newAmount) || (currency == 'dollar' && gameVars.money <= totalcost + newAmount)) || newWorkerCount >= limit)
                        break;

                    totalcost += newAmount;
                }

                if(currency == 'bc'){
                    //BUYING WITH BOSS CURRENCY
                    if(gameVars.bossCurrency >= totalcost && newWorkerCount <= limit && (gameVars.employed[workerType][0]+i) <= limit){
                        gameVars.bossCurrency -= totalcost;
                        gameVars.employed[workerType][0] += i;
                        self.sendVars();

                        if(gameVars.workersLastPaid == 0)
                            gameVars.workersLastPaid = new Date().getTime();
                    }
                }else{
                    //BUYING WITH MONEY
                    if(gameVars.money >= totalcost && newWorkerCount <= limit && (gameVars.employed[workerType][0]+i) <= limit){
                        gameVars.money -= totalcost;
                        gameVars.employed[workerType][0] += i;
                        self.sendVars();

                        if(gameVars.workersLastPaid == 0)
                            gameVars.workersLastPaid = new Date().getTime();
                    }
                }

                //DON'T LET THEM GO OVER WORKER LIMIT!
                if(gameVars.employed[workerType][0] > limit)
                    gameVars.employed[workerType][0] = limit;
            }else{
                self.popup('WHOOPS!', 'You can\'t buy this type of worker yet!', '', 0);
            }
        }else{
            self.popup('WHOOPS!', 'You can\'t buy this type of worker.', '', 0);
        }
    }catch(e){
        console.log(e);
    }
}

Game.prototype.buyWorker = function(workerType){
    try {
        var self = this;
        var gameVars = this.player.gameVars;
        var items = this.player.resources.items;
        
        if(items.workers[workerType].buyable){
            if(workerType != 'enderminer' || (workerType == 'enderminer' && !(gameVars.ebHealth > 0))){
                var workerCount = gameVars.employed[workerType][0];

                //currency type?
                var cost;
                if(items.workers[workerType].currency == 'dollar')
                    cost = items.workers[workerType].price * (Math.pow(1.025, workerCount));
                else
                    cost = items.workers[workerType].price * (Math.pow(1.00025, workerCount));

                if((workerCount + 1) <= (Math.floor(items.workers[workerType].limit * gameVars.maxWorkerMultiplier))) {
                    if(items.workers[workerType].currency == 'bc'){
                        //BUYING WITH BC
                        if(gameVars.bossCurrency >= cost){
                            gameVars.bossCurrency -= cost;
                            gameVars.employed[workerType][0] += 1;
                            self.sendVars();

                            if(gameVars.workersLastPaid == 0)
                                gameVars.workersLastPaid = new Date().getTime();
                        }else{
                            self.popup('WHOOPS!', 'You need more boss currency to hire this worker.', '', 0);
                        }
                    }else{
                        //BUYING WITH MONEY
                        if(gameVars.money >= cost){
                            gameVars.money -= cost;
                            gameVars.employed[workerType][0] += 1;
                            self.sendVars();

                            if(gameVars.workersLastPaid == 0)
                                gameVars.workersLastPaid = new Date().getTime();
                        }else{
                            self.popup('WHOOPS!', 'You need more money to hire this worker.', '', 0);
                        }
                    }
                }else{
                    self.popup('WHOOPS!', 'You can not buy any more workers of that type.', '', 0);
                }

                if(gameVars.employed[workerType][0] > Math.floor(items.workers[workerType].limit * gameVars.maxWorkerMultiplier))
                    gameVars.employed[workerType][0] = Math.floor(items.workers[workerType].limit * gameVars.maxWorkerMultiplier);
            }else{
                self.popup('WHOOPS!', 'You can\'t buy this type of worker yet!', '', 0);
            }
        }else{
            self.popup('WHOOPS!', 'You can\'t buy this type of worker.', '', 0);
        }
    }catch(e){
        console.log(e);
    }
}

Game.prototype.sellWorker = function(workerType){
    try {
        var self = this;
        var gameVars = this.player.gameVars;
        var items = this.player.resources.items;

        if(gameVars.employed[workerType][0] > 0){
            //give them back BC or money?
            if(items.workers[workerType].currency == 'bc')
                gameVars.bossCurrency += items.workers[workerType].sell;
            else
                gameVars.money += items.workers[workerType].sell;
                
            gameVars.employed[workerType][0] -= 1;
            self.sendVars();
        }
    }catch(e){
        console.log(e);
    }
}

Game.prototype.buySoldier = function(soldierType, x){
    try {
        var self = this;
        var gameVars = this.player.gameVars;
        var items = this.player.resources.items;

        var name = items.soldiers[soldierType].name;
        var cost = items.soldiers[soldierType].price;
        var amount = (x) ? x : 1;

        cost = cost * amount;

        if(gameVars.money >= cost) {
            if(amount == 1) {
                gameVars.money -= cost;
                gameVars.employedSoldiers[soldierType] += amount;
                self.sendVars();
            }else if(amount > 1) {
                if (gameVars.money >= cost) {
                        gameVars.money -= cost;
                        gameVars.employedSoldiers[soldierType] += amount;
                        self.sendVars();
                }
            }
        }
    }catch(e){
        console.log(e);
    }
}

Game.prototype.sellSoldier = function(soldierType, x){
    try {
        var self = this;
        var gameVars = this.player.gameVars;
        var items = this.player.resources.items;
        var amount = (x > 0) ? x : 1;
        if(gameVars.employedSoldiers[soldierType] >= amount) {
            gameVars.money += items.soldiers[soldierType].sell * amount;
            gameVars.employedSoldiers[soldierType] -= amount;
            self.sendVars();
        }else{
            self.popup('WHOOPS!', 'You do not have this many to sell.', '', 0);
        }
    }catch(e){
        console.log(e);
    }
}

Game.prototype.toggleBuyMode = function(){
    this.player.gameVars.scientistBCMode = !this.player.gameVars.scientistBCMode;
}

Game.prototype.buyXScientists = function(amount){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if(amount > 0){
        if(!gameVars.scientistBCMode){
            var totalcost = 1000000 * (Math.pow(1.0005, gameVars.scientists));

            var i = 1;
            for (i; i <= amount; i++) {
                    var newAmount = 1000000 * (Math.pow(1.0005, gameVars.scientists + i));
                    totalcost += newAmount;
            }

            if(gameVars.money >= totalcost) {
                gameVars.scientists += amount;
                gameVars.money -= totalcost;
                self.sendVars();
            }else{
                self.popup('WOOPS', 'You can\'t afford to purchase that many scientists!', '', 0);
            }
        }else{
            var cost = amount*gameVars.scientistCostBC;

            if(gameVars.bossCurrency >= cost){
                gameVars.scientistsBC += amount;
                gameVars.bossCurrency -= cost;
                self.sendVars();
            }else{
                self.popup('WHOOPS!', 'You can\'t afford to purchase that many scientists!', '', 0);
            }
        }
    }else{
        self.popup('WHOOPS!', 'Please enter in a valid amount you wish to purchase.', '', 0);
    }
}

Game.prototype.buyScientist = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if(!gameVars.scientistBCMode){
        var cost = 1000000 * (Math.pow(1.0005, gameVars.scientists));

        if (gameVars.money >= cost) {
                gameVars.scientists++;
                gameVars.money -= cost;
                self.sendVars();
        } else {
                self.popup('WHOOPS!', 'You need more money to purchase a scientist.', '', 0);
        }
    }else{
        if(gameVars.bossCurrency >= gameVars.scientistCostBC){
            gameVars.scientistsBC++;
            gameVars.bossCurrency -= gameVars.scientistCostBC;
            self.sendVars();
        }else{
            self.popup('WHOOPS!', 'You need more BC to purchase a scientist.', '', 0);
        }
    }
}

Game.prototype.sellScientist = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if(!gameVars.scientistBCMode){
            var cost = 1000000 * (Math.pow(1.0005, gameVars.scientists));

            if (gameVars.scientists > 0) {
                    gameVars.scientists--;
                    gameVars.money += Math.floor(cost / 4);
                    self.sendVars();
            }else{
                self.popup('WHOOPS!', 'You can\'t sell something that you don\'t have. If you have scientists, but cannot sell them for money, this may be due to the fact you purchased them with Boss Currency. (BC)', '', 0);
            }
    }else{
        if (gameVars.scientistsBC > 0){
            gameVars.scientistsBC--;
            gameVars.bossCurrency += 1;
            self.sendVars();
        }else{
            self.popup('WHOOPS!', 'You can\'t sell something that you don\'t have. If you have scientists, but cannot sell them for Boss Currency, this may be due to the fact you purchased them with money.', '', 0);
        }
    }
}

Game.prototype.buyMaxScientists = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if(!gameVars.scientistBCMode){
        var totalcost = 1000000 * (Math.pow(1.0005, gameVars.scientists));

        var i = 1;
        for (i; gameVars.money >= totalcost; i++) {
                var newAmount = 1000000 * (Math.pow(1.0005, gameVars.scientists + i));

                if (!(gameVars.money >= totalcost + newAmount))
                        break;

                totalcost += newAmount;
        }

        if(gameVars.money >= totalcost) {
            gameVars.scientists += i;
            gameVars.money -= totalcost;
            self.sendVars();
        }else{
            self.popup('WHOOPS!', 'You can\'t afford this!', '', 0);
        }
    }else{
        var amount = Math.floor(gameVars.bossCurrency/gameVars.scientistCostBC);
        var cost = amount*gameVars.scientistCostBC;

        if(gameVars.bossCurrency >= cost && amount > 0){
            gameVars.scientistsBC += amount;
            gameVars.bossCurrency -= cost;
            self.sendVars();
        }else{
            self.popup('WHOOPS!', 'You can\'t afford this.', '', 0);
        }
    }
}

Game.prototype.generateOres = function(amount, pickaxe){
    var items = this.player.resources.items;
    pickaxe = items.pickaxes[pickaxe];
    
    var oresMined = {};
    var left = amount;

    //loop through # of ores mine d, and mine ores based off of probability
    for (var ore in items.ores) {
            //do they have a strong enough pickaxe, and did they get lucky enough
            if (pickaxe.sharpness >= items.ores[ore].hardness) {
                    oresMined[ore] = Math.round(left * items.ores[ore].prob);
                    left -= oresMined[ore];
            }
    }

    return oresMined;
}

Game.prototype.addOreToVault = function(ore){
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    if((self.amountOfOreInVault() < gameVars.vault_max_storage) || gameVars.autoPilotEnabled) {
        for (var o in ore) {
            var amount = ore[o];
            var inVault = self.amountOfOreInVault();

            if(typeof gameVars.vault[o] == 'undefined')
                gameVars.vault[o] = 0;

            //how much can we add without overflowing?
            if (inVault + amount < gameVars.vault_max_storage) {
                gameVars.vault[o] += amount;
            } else {
                //well then how many can we squeeze in?
                gameVars.vault[o] += (gameVars.vault_max_storage - inVault);
            }

            //finally, one last check
            if(self.amountOfOreInVault() >= gameVars.vault_max_storage) {
                if(gameVars.autoPilotEnabled) {
                    self.sellVaultOres();
                }else{
                    break;
                }
            }
        }
    }
}

Game.prototype.amountOfOreInVault = function(){
    var self = this;
    
    var x = 0;
    for (var ore in self.player.gameVars.vault) {
            x += self.player.gameVars.vault[ore];
    }
    return ( typeof x == 'NaN') ? 0 : x;
}

Game.prototype.sellVaultOres = function() {
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    var worth = 0;
    for(var ore in gameVars.vault) {
        var keep = (typeof gameVars.vaultStorageSettings[ore] != 'number') ? 0 : gameVars.vaultStorageSettings[ore];

        if(gameVars.vault[ore] > keep) {
            var sold = (gameVars.vault[ore] - keep);
            worth += items.ores[ore].worth * sold;
            gameVars.vault[ore] -= sold;
        }
    }

    gameVars.totalMoneyEarned += worth;
    gameVars.money += worth;
    
    self.player.client.emit('vaultFull', false);
}

Game.prototype.updateVaultSettings = function(ores){
    for(var ore in ores)
        this.player.gameVars.vaultStorageSettings[ore] = ores[ore];
}

Game.prototype.upgradePickaxe = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    var nextPickaxe = self.nextPickaxe();
    
    if(nextPickaxe){
        gameVars.money -= this.player.resources.items.pickaxes[nextPickaxe].price;
        gameVars.pickaxe_type = nextPickaxe;

        if (!gameVars.achievements['upgradedPickaxe']) {
                gameVars.achievements['upgradedPickaxe'] = true;
                self.popup('ACHIEVEMENT UNLOCKED!', '<table><tr><td><img src="game/img/icons/icon_1.png"></td><td style="font-size:20px;">FIRST UPGRADE...</td></tr></table>', false, 4000);
        }

        self.sendVars();
    }
}

Game.prototype.upgradeVault = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    var currentVaultUpgrade = (gameVars.vault_max_storage / gameVars.vault_storage_per_upgrade) - 1;
    var priceModifier = (currentVaultUpgrade * gameVars.vault_cost_per_upgrade_modifier);
    var nextVaultUpgradePrice = (priceModifier == 0) ? gameVars.vault_cost_per_upgrade_baseprice : gameVars.vault_cost_per_upgrade_baseprice * priceModifier;
    
    if(gameVars.money >= nextVaultUpgradePrice) {
            gameVars.money -= nextVaultUpgradePrice;
            gameVars.vault_max_storage += gameVars.vault_storage_per_upgrade;
            self.sendVars();
    }
}

Game.prototype.upgradeAutoPilot = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if (gameVars.money >= gameVars.autoPilotCost) {
            gameVars.money -= gameVars.autoPilotCost;
            gameVars.hasAutoPilot = true;
            gameVars.autoPilotEnabled = true;
            self.mine();
            self.sellVaultOres();
            self.sendVars();
    }
}

Game.prototype.upgradeHellPickaxe = function() {
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    
    if(gameVars.shrineHealth == 0 && gameVars.money >= items.pickaxes['underworld'].price) {
        gameVars.pickaxe_type = 'underworld';
        gameVars.money -= items.pickaxes['underworld'].price;
        self.sendVars();
    }
}

Game.prototype.upgradeEnderPickaxe = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    
    if(gameVars.ebHealth <= 0 && gameVars.money >= items.pickaxes['ender'].price) {
            gameVars.pickaxe_type = 'ender';
            gameVars.money -= items.pickaxes['ender'].price;
            self.sendVars();
    }
}

Game.prototype.upgradeFinalPickaxe = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    
    if(gameVars.pickaxe_type == 'ender' && gameVars.money >= items.pickaxes['final'].price) {
            gameVars.pickaxe_type = 'final';
            gameVars.money -= items.pickaxes['final'].price;
            self.sendVars();
    }
}

Game.prototype.upgradeAntimatterPickaxe = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    
    if (gameVars.pickaxe_type == 'final' && gameVars.bossCurrency >= items.pickaxes['antimatter'].bc) {
            gameVars.pickaxe_type = 'antimatter';
            gameVars.bossCurrency -= items.pickaxes['antimatter'].bc;
            self.sendVars();
    }
}

Game.prototype.upgradeAutoWage = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    
    if(gameVars.money >= gameVars.workerAutoWageCost){
        gameVars.money -= gameVars.workerAutoWageCost;
        gameVars.workerAutoWage = true;
        self.sendVars();
    }
}

Game.prototype.buyLawMaker = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    
    if(gameVars.money >= gameVars.lawMakerCost){
        gameVars.money -= gameVars.lawMakerCost;
        gameVars.lawMakers++;
        self.sendVars();
    }
}

Game.prototype.befriendGolem = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    
    if(gameVars.money >= gameVars.golemCost && !gameVars.befriendedWitch && !gameVars.befriendedGolem) {
        gameVars.money -= gameVars.golemCost;

        gameVars.befriendedGolem = true;
        gameVars.canGetZombieProtection = false;

        gameVars.dcUnlocked = true;
        gameVars.money += gameVars.zbMoneyStolen;
        clearInterval(gameVars.zbInterval);
        
        var message = '<img src="game/img/npc/golem_face.png" style="margin-right:6px;" width="40" height="40" class="left">You don\'t have to worry about him anymore. Let\'s just say it\'s been taken care of. Oh, and that $' + self.funcs.numberFormat(gameVars.zbMoneyStolen) + ' stolen from you? Here, have it back.';
        self.popup('Golem', message, '', 0);
        
        self.donChikolio();
        self.sendVars();
    }
}

Game.prototype.befriendWitch = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    
    if(gameVars.money >= gameVars.witchCost && !gameVars.befriendedWitch && !gameVars.befriendedGolem) {
            gameVars.money -= gameVars.witchCost;

            gameVars.befriendedWitch = true;
            gameVars.canGetZombieProtection = false;

            gameVars.dcUnlocked = true;
            clearInterval(gameVars.zbInterval);

            var message = '<img src="game/img/npc/witch_face.png" style="margin-right:6px;" width="40" height="40" class="left">Phew! Let\'s just say that zombie won\'t be a problem anymore. It\'s nice to meet you; hope we can see eachother again sometime!';
            self.popup('Witch', message, '', 0);
            
            self.donChikolio();
            self.sendVars();
    }
}

Game.prototype.partWays = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    
    if(gameVars.money >= gameVars.partWaysCost && gameVars.dcOption == 1) {
        gameVars.money -= gameVars.partWaysCost;
        gameVars.dcOption = 2;
        self.sendVars();
    }
}

Game.prototype.ignitePortal = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if (gameVars.money >= gameVars.portalIgniteCost && gameVars.portalBuilt && !gameVars.portalLit) {
            gameVars.money -= gameVars.portalIgniteCost;
            gameVars.dcRanAway = true;
            gameVars.portalLit = true;
            gameVars.ulUnlocked = true;
            
            if(typeof self.dcInterval != 'undefined')
                clearInterval(self.dcInterval);

            var message = '<img src="game/img/npc/chicken.png" style="margin-right:6px;" width="40" height="40" class="left"> WHAT ARE YOU DOING?! YOU ARE OPENING A PORTAL TO HELL! YOU\'VE KILLED US ALL!!!!!!!!!!!!!!!';
            self.popup('Don Chikolio', message, '', 0);
            
            self.sendVars();
            self.underlord();
    }
}

Game.prototype.nextPickaxe = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    
    var i = 1;
    var pickaxeIndex = 1;
    var totalPickaxes = this.funcs.objSize(items.pickaxes);
    var nextPickaxe = '';

    //get next upgradeable pickaxe
    for (var pickaxe in items.pickaxes) {
            //this is our pickaxe
            if (items.pickaxes[pickaxe].name == items.pickaxes[gameVars.pickaxe_type].name)
                    pickaxeIndex = i;

            //this is the next pickaxe in the array/object
            if (i == (pickaxeIndex + 1)) {
                if (items.pickaxes[pickaxe].canbeupgradedto)
                        nextPickaxe = pickaxe;
                else
                        nextPickaxe = false;
            }

            i++;
    }
    
    return nextPickaxe;
}

Game.prototype.battle = function(bossDetails){
    var self = this;
    var gameVars = this.player.gameVars;
    var items = this.player.resources.items;
    
    var enemiesKilled = 0;
    var defendersKilled = 0;
    var totalDefenders = 0;

    //after they battle it out, this is the remaining power of your army
    var remainingDefensePower = 0;
    for (var soldier in gameVars.employedSoldiers) {
            //make sure they actually have soldiers to fight with
            if (gameVars.employedSoldiers[soldier] > 0) {
                    //if they are in the underworld, only underworld able troops can fight
                    if (gameVars.overWorld || (!gameVars.overWorld && gameVars.portal == 1) || (!gameVars.overWorld && gameVars.portal == 0 && items.soldiers[soldier].underworld_able)) {
                            //make sure there are still enemies left to kill
                            if (enemiesKilled < gameVars[bossDetails.prepend + 'Soldiers']) {
                                    var kpe = items.soldiers[soldier].kpe;

                                    //enemies killed for this class of soldier,
                                    //then add that number to the total enemiesKilled
                                    var ek = kpe * (gameVars.employedSoldiers[soldier]);
                                    ek = ((enemiesKilled + ek) > gameVars[bossDetails.prepend + 'Soldiers']) ? gameVars[bossDetails.prepend + 'Soldiers'] : ek;
                                    enemiesKilled += ek;

                                    gameVars[bossDetails.prepend + 'Soldiers'] -= ek;

                                    //how many soldiers died?
                                    //then kill them! muaha!
                                    totalDefenders += gameVars.employedSoldiers[soldier];

                                    //calculating the number of defenders lived
                                    var df = (gameVars.employedSoldiers[soldier] - Math.round(((gameVars.employedSoldiers[soldier] * kpe) - ek) / kpe));
                                    df = (df < 0) ? 0 : df;

                                    defendersKilled += df;
                                    gameVars.employedSoldiers[soldier] -= df;

                                    remainingDefensePower += gameVars.employedSoldiers[soldier] * kpe;
                            }
                    }
            }
    }

    var won = ((gameVars[bossDetails.prepend + 'Soldiers'] > remainingDefensePower)) ? false : true;

    var moneyStolen = (!won && gameVars.money > 0) ? gameVars.money * .5 : 0;
    gameVars.money -= moneyStolen;

    //looting
    var extra = '';
    if (won) {
            //did they get a portal part?
            if ((self.funcs.rand(0, 100) < gameVars.portalPartChance) && (bossDetails.hasPortalParts) && gameVars.portalParts < 10) {
                    var num = self.funcs.rand(1, 3);

                    //let's not have more than 10 portal parts, ok?
                    if (gameVars.portalParts + num > 10)
                            num -= (gameVars.portalParts + num) - 10;

                    extra = 'Rummaging through army remains, you find ' + num + ' portal parts.';
                    gameVars.portalParts += num;
            } else if (self.funcs.rand(0, 100) < 80) {
                    moneyFound = 50 * enemiesKilled;

                    //update stats!
                    gameVars.totalMoneyEarned += moneyFound;
                    gameVars.statLootMoney += moneyFound;
                    gameVars.money += moneyFound;

                    extra = 'Rummaging through army remains, you find $' + self.funcs.numberFormat(moneyFound) + '.';

                    if (gameVars.statLootMoney >= 15000000 && !gameVars.achievements['pillager1']) {
                            gameVars.achievements['pillager1'] = true;
                            self.popup('ACHIEVEMENT UNLOCKED!', '<table><tr><td><img src="game/img/icons/icon_1.png"></td><td style="font-size:20px;">PILLAGER...</td></tr></table>', false, 4000);
                    }
            } else {
                    extra = 'Rummaging through army remains, you find nothing.';
            }
    }

    //update stats
    gameVars.statEnemiesKilled += enemiesKilled;
    gameVars.statDefendersKilled += defendersKilled;
    if (won)
            gameVars.statBattlesWon++;
    else
            gameVars.statBattlesLost++;

    var message = '<img src="game/img/icons/warning.png" style="margin-right:6px;" width="40" height="40" class="left"> You ' + ((!won) ? 'lost' : 'won') + ' the battle with ' + bossDetails.name + '! You killed ' + enemiesKilled + ' enemies, and lost ' + defendersKilled + ' soldiers. ' + bossDetails.name + '\'s remaining army of ' + gameVars[bossDetails.prepend + 'Soldiers'] + " soldiers " + ((!won) ? 'beat' : 'lost to') + ' yours of ' + (totalDefenders - defendersKilled) + '. $' + self.funcs.numberFormat(moneyStolen) + ' was stolen from you. ';

    self.popup('Battle Report', message + extra, '', 0);

    gameVars[bossDetails.prepend + 'Active'] = false;
    gameVars[bossDetails.prepend + 'Chance'] = 0;

    self.sendVars();
}


Game.prototype.attackShrine = function(){
    var self = this;
    var items = this.player.resources.items;
    var gameVars = this.player.gameVars;
    var d = new Date().getTime();

    //only every 30 seconds they can attack
    if (d - gameVars.shrineLastAttack >= 30000) {
            var attackPower = 0;

            //we would use the getArmyStrength() function, however
            //this looks for underworld_able only soldiers
            for(var s in gameVars.employedSoldiers) {
                if(items.soldiers[s].underworld_able) {
                        var kpe = items.soldiers[s].kpe;

                        attackPower += gameVars.employedSoldiers[s] * kpe;
                }
            }

            gameVars.shrineHealth -= attackPower;

            if (gameVars.shrineHealth <= 0) {
                    gameVars.shrineHealth = 0;
                    clearInterval(self.ulInterval);

                    var message = '<img src="game/img/npc/zombiepigman_face.png" style="margin-right:3px;" width="40" height="40" class="left"> ARRRRRRRRRRRRRGH! THE SHRINE! I....I\'VE FAILED..';
                    self.popup('Underlord', message, '', 0);
            }

            gameVars.shrineLastAttack = d;
            self.sendVars();
    }
}

Game.prototype.launchAttack = function(boss){
    var self = this;
    var items = this.player.resources.items;

    if(self.player.getArmyStrength() > 0)
        self.battle(items.bosses[boss]['details']);
    else
        self.popup('WHOOPS!', 'You can\'t launch an attack without any soldiers!', '', 0);
}

Game.prototype.research = function(){
    var self = this;
    var research_projects = this.player.resources.research_projects;
    var gameVars = this.player.gameVars;
    
    this.researching = true;
    this.researchTimer = setTimeout(function() {
            if(self.funcs.objSize(gameVars.projects) > 0 && gameVars.scientists > 0) {
                var project;
                for(var p in gameVars.projects) {
                    project = p;
                    break;
                }
                
                //scientist speed (including boosts)
                var scientists_rs_speed = gameVars.scientistTime; 
                if(typeof self.player.resources.activatedItems['speed_research'] != 'undefined')
                    scientists_rs_speed = scientists_rs_speed*2;
                
                //project time lapsed
                var research_time = ((gameVars.scientists+gameVars.scientistsBC)*scientists_rs_speed);
                
                gameVars.projects[project] += research_time;

                if(gameVars.projects[project] >= research_projects[project].time){
                    gameVars.projects[project] = undefined;
                    gameVars.projects = self.funcs.removeUndefined(gameVars.projects);
                    
                    //do they have diminishing research?
                    var dr = (typeof self.player.resources.activatedItems['diminishing_research'] != 'undefined') ? true : false;

                    if(project == 'workeropm'){
                        gameVars.workerOPMResearch++;
                        research_projects[project].func(gameVars, dr);
                        self.startResearch('workeropm');
                    }else{
                        research_projects[project].func();
                        var modifiers = self.player.resources.gameVarModifiers;
                        for(var modifier in modifiers)
                            gameVars[modifier] = modifiers[modifier];
                    }

                    gameVars.finishedResearch[project] = true;

                    switch (project) {
                        case 'workeropm':
                            self.startResearch('', 'workeropm');
                            break;
                        case 'unknown1':
                            var m1 = '<img src="game/img/npc/steve.png" style="margin-right:6px;" width="40" height="40" class="left">Dammit! Sir, I\'m sorry to report that, during our "unknown" research project, one of our scientists died; however, we managed to get the research completed on time.';
                            self.popup('INCIDENT REPORT', m1, '', 0);

                            gameVars.scientists--;
                            break;
                        case 'unknown3':
                            var m2 = '<img src="game/img/npc/steve.png" style="margin-right:6px;" width="40" height="40" class="left">No, no! What is it?! It\'s in the lab!';
                            self.popup('INCIDENT REPORT', m2, '', 0);

                            gameVars.scientists = Math.round(gameVars.scientists / 2);
                            self.enderboss();
                            break;
                        case 'portal1':
                            gameVars.portal = 1;
                            break;
                    }
                    
                    self.sendVars();
                    self.player.client.emit('resources', self.player.resources);
                    self.player.client.emit('drawResearchProjects', true);
                }
            }
        
            self.sendVars();
            self.player.client.emit('drawResearchProgress', true);
            
            if(self.funcs.objSize(gameVars.projects) == 0){
                self.researching = false;
            }else{
                self.research();
            }
                
    }, 1000);
}

Game.prototype.startResearch = function(project){
    var self = this;
    var research_projects = this.player.resources.research_projects;
    var gameVars = this.player.gameVars;

    var obj = research_projects[project];
    
    if(typeof obj != 'undefined'){
        //first, let's see if they have the required resources
        var hasRequiredResources = true;
        if(self.funcs.objSize(obj.resources) > 0) {
            for(var x in obj.resources) {
                if(typeof gameVars.vault[x] == 'undefined' || gameVars.vault[x] < obj.resources[x]) {
                        hasRequiredResources = false;
                        break;
                }
            }
        }

        if (gameVars.money >= obj.price && hasRequiredResources) {
                gameVars.money -= obj.price;

                //remove the resources from their vault
                if(self.funcs.objSize(obj.resources) > 0) {
                    for(var y in obj.resources) {
                            gameVars.vault[y] -= obj.resources[y];
                    }
                }

                gameVars.projects[project] = 0;

                if (!self.researching && self.funcs.objSize(gameVars.projects) > 0)
                        self.research();

                self.sendVars();
                self.player.client.emit('drawResearchProjects', true);
                self.player.client.emit('drawResearchProgress', true);
        }else{
            self.popup('Whoops!', 'Please make sure you the required money and resources to research this project', '', 0);
        }
    }
}

Game.prototype.loadResearchLab = function(){
    var self = this;
    var research_projects = this.player.resources.research_projects;
    var gameVars = this.player.gameVars;
    
    if(self.funcs.objSize(gameVars.finishedResearch) > 0){
        for(var x in gameVars.finishedResearch){
            //some research projects may have been removed from
            //the game, so lets remove them from their finished projects
            if(typeof research_projects[x] == 'undefined'){
                gameVars.finishedResearch[x] = undefined;
                gameVars.finishedResearch = self.funcs.removeUndefined(gameVars.finishedResearch);
            }else{
                //not removed!
                if(x == 'workeropm')
                    research_projects[x].func(gameVars);
                else
                    research_projects[x].func();
            }
        }
    }

    if(self.funcs.objSize(gameVars.projects) > 0) {
        //resume researching of projects
        if (!gameVars.researching)
                self.research();
    }
}

Game.prototype.cancelResearch = function(project){
    var self = this;
    var research_projects = this.player.resources.research_projects;
    var gameVars = this.player.gameVars;
    
    if(typeof gameVars.projects[project] != 'undefined'){
        gameVars.money += research_projects[project].price;

        gameVars.projects[project] = undefined;
        gameVars.projects = self.funcs.removeUndefined(gameVars.projects);
        
        self.sendVars();
        self.player.client.emit('drawResearchProjects', true);
        self.player.client.emit('drawResearchProgress', true);
    }
}

Game.prototype.constructLab = function(){
    var gameVars = this.player.gameVars;
    
    gameVars.money -= 100000000
    gameVars.ownsResearchLab = true;
    this.sendVars();
}

Game.prototype.loadItems = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    
    for(var i = 0; i < gameVars.inventory.length; i++){
        var item = gameVars.inventory[i].item;
        if(gameVars.inventory[i].activated && self.itemHasFunc(item))
            self.player.resources.items.items[item].func(gameVars.active_item_bonuses);
    }
    
    self.loadGameVarModifiers();
}

//gets the drop table object from random boss vars
Game.prototype.getDrops = function(table){
    var self = this;
    var drops = [];
    for(var item in table){
        if(self.funcs.rand(0, 100) <= table[item]){
            self.addItem(item);
            drops.push(item);
        }
    }
    return drops;
}

Game.prototype.activateItem = function(pos){
    var self = this;
    var gameVars = this.player.gameVars;
    
    //make sure the item exists, yeah?
    if(self.hasItemByID(pos) && !self.isActivated(pos)){
        var item = gameVars.inventory[pos].item;
        
        //item of this type is already activated
        //so let's stack them
        if(self.typeActivated(item)){
            //index of the activated item
            var activatedIndex = 0;
            
            for(var i = 0; i < gameVars.inventory.length; i++){
                if(gameVars.inventory[i].item == item && gameVars.inventory[i].activated){
                    activatedIndex = i;
                    break;
                }
            }
            
            //add the stacked items life to the activated
            //then remove the item that was stacked
            gameVars.inventory[activatedIndex].life += gameVars.inventory[pos].life;
            self.removeItem(pos);
        }else{
            gameVars.inventory[pos].activated = true;
            
            //activate function if it has one
            if(self.itemHasFunc(item))
                self.player.resources.items.items[item].func(gameVars.active_item_bonuses);
        }
        
        self.player.client.emit('resources', self.player.resources);
    }
}

Game.prototype.removeItem = function(pos){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if(self.hasItemByID(pos)){
        var item = gameVars.inventory[pos].item;
        
        if(self.itemHasFunc(item) && gameVars.inventory[pos].activated)
            self.player.resources.items.items[item].de_func(gameVars.active_item_bonuses);
        
        gameVars.inventory.splice(pos, 1);
        self.sendVars();
        
        self.player.client.emit('resources', self.player.resources);
    }
}

Game.prototype.isActivated = function(pos){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if(self.hasItemByID(pos))
        return (gameVars.inventory[pos].activated) ? true : false;
    else
        return false;
}

Game.prototype.hasItem = function(item){
    var gameVars = this.player.gameVars;
    if(typeof this.player.resources.items.items[item] != 'undefined'){
        var found = false;
        
        //search through inventory array and find item
        for(var i = 0; i < gameVars.inventory.length; i++){
            if(gameVars.inventory[i].item == item && gameVars.inventory[i].life > 0){
                found = true;
                break;
            }
        }
        return found;
    }else{
        return false;
    }
}

Game.prototype.hasItemByID = function(id){
    var gameVars = this.player.gameVars;
    return (typeof gameVars.inventory[id] != 'undefined') ? true : false;
}

//checks whether an item of the given type
//has been activated
Game.prototype.typeActivated = function(item){
    var gameVars = this.player.gameVars;
    
    var found = false;
    for(var i = 0; i < gameVars.inventory.length; i++){
        if(gameVars.inventory[i].item == item && gameVars.inventory[i].activated){
            found = true;
            break;
        }
    }
    return found;
}

Game.prototype.addItem = function(item){
    var self = this;
    var gameVars = this.player.gameVars;
    
    if(typeof self.player.resources.items.items[item] != 'undefined' && gameVars.inventory.length < gameVars.inventory_capacity){
        var iObj = self.player.resources.items.items[item];
        gameVars.inventory.push({
            'item' : item,
            'life' : iObj.life,
            'activated' : false
        });
    }
}

Game.prototype.itemHasFunc = function(item){
    var self = this;
    if(typeof self.player.resources.items.items[item].func != 'undefined')
        return true;
    else
        return false;
}

Game.prototype.expEarnedBasedOnBF = function(lvl){
    var exp = Math.round(1.2*lvl*(1+(lvl/35)))*this.player.gameVars.expModifier;
    
    if(typeof this.player.resources.activatedItems['double_exp'] != 'undefined')
        return exp*2;
    else
        return exp;
}

Game.prototype.lvlExp = function(lvl){
    return (25*lvl*(1+lvl));
}

//second parameter decides if we will return a capped level
Game.prototype.expLvl = function(exp, limit){
    var lvl = Math.floor((Math.sqrt(625+100*exp)-25)/50);
    
    if(lvl >= 100 && !limit)
        return 100;
    else
        return lvl;
}

Game.prototype.getHitDamage = function(lvl){
    var damage = Math.pow(lvl*2, 1.04);
    damage += this.funcs.rand(0, 3);
    
    //if the attack boost item is activated!
    if(typeof this.player.resources.activatedItems['attack_boost'] != 'undefined')
        damage += damage*.2;
    
    return damage;
}

Game.prototype.gbToggleLobby = function(){
    var self = this;
    var gameVars = this.player.gameVars;
    if(self.player.loggedIn){
        if(!self.inLobby){
            if(self.globalboss.matchActive){
                self.popup('Game in progress', 'You cannot join the event lobby at this time.', '', 0);
            }else if(!self.globalboss.lobbyActive){
                self.popup('Lobby closed', 'The lobby is not open at this time.', '', 0);
            }else{
                self.inLobby = true;
                self.globalboss.playerJoin(self.player.userid, {
                    level : self.expLvl(gameVars.exp, true),
                    username : self.player.username
                }, self);
                self.player.client.emit('globalbossToggleLobby', true);
            }
        }else{
            self.inLobby = false;
            self.globalboss.playerLeave(self.player.userid, self.player.username);
            self.player.client.emit('globalbossToggleLobby', false);
        }
    }else{
        self.popup('WHOOPS!', 'You need to be logged in to join this event.', '', 0);
    }
}

//when a user attacks the global boss (clicks on its image
//we receive the coordinates of that click, and send it to all
//players in the match to be displayed
Game.prototype.gbAttacked = function(coords){
    var self = this;
    var gameVars = this.player.gameVars;
    if(self.inLobby)
        self.globalboss.attacked(self.player.userid, Math.round(self.getHitDamage(self.expLvl(gameVars.exp))), coords);
}

Game.prototype.gbGiveMinion = function(){
    var self = this;
    var items = this.player.resources.items;
    var gameVars = this.player.gameVars;   
    var limit = (Math.floor(items.workers['gb_capturedminion'].limit * gameVars.maxWorkerMultiplier));
    
    //give them one if they are still below limit
    if(gameVars.employed['gb_capturedminion'][0] < limit)
        gameVars.employed['gb_capturedminion'][0]++;
}

Game.prototype.popup = function(title, html, buttons, timer){
    this.player.client.emit('popup', {
        title: title,
        html : html,
        buttons : buttons,
        timer : timer
    });
}

Game.prototype.admin = function(){
    var self = this;
    self.adminInterval = setInterval(function(){
        var players = {};
        for(var player in self.player.players){
            if(self.player.players[player].active == true)
                players[player] = self.player.players[player].username;
        }
        
        var html = '<h3>Players ('+ self.funcs.objSize(players) +')</h3>';
            html += '<select name="users">';
            
                for(var player in players)
                    html += '<option value="'+ player +'">'+ players[player] +'</option>';
                
            html += '</select>';
        
        self.player.client.emit('admin_users', html);
    },10000);
}

Game.prototype.admin_selectuser = function(userid){
    var self = this;
    if(self.player.rights >= 2){
    
        if(typeof self.player.players[userid]['active'] != 'undefined' && self.player.players[userid].active == true){
            var html = '<h3>Viewing actions for '+ self.player.players[userid].username +'</h3>';
                html += '<button name="admin-kick/'+ userid +'">Kick user</button>';

            self.player.client.emit('admin_user', html);
        }
    }
}

Game.prototype.admin_kick = function(userid){
    if(this.player.rights >= 2)
        this.control.kick.push(parseInt(userid));
}

Game.prototype.admin_initUpdate = function(){
    if(this.player.rights >= 2)
        this.control.initUpdate = true;
}

Game.prototype.sendVars = function(){
    var gameVars = this.player.gameVars;
    var time = new Date().getTime();
    
    //achievements
    if(!gameVars.achievements['millionaire'] && gameVars.totalMoneyEarned > 1000000) {
        gameVars.achievements['millionaire'] = true;
        this.popup('ACHIEVEMENT UNLOCKED!', '<table><tr><td><img src="game/img/icons/icon_1.png"></td><td style="font-size:20px;">MILLIONAIRE...</td></tr></table>', false, 4000);
    }

    if(!gameVars.achievements['billionaire'] && gameVars.totalMoneyEarned > 1000000000) {
        gameVars.achievements['billionaire'] = true;
        this.popup('ACHIEVEMENT UNLOCKED!', '<table><tr><td><img src="game/img/icons/icon_1.png"></td><td style="font-size:20px;">BILLIONAIRE...</td></tr></table>', false, 4000);
    }

    if(!gameVars.achievements['trillionaire'] && gameVars.totalMoneyEarned > 1000000000000) {
        gameVars.achievements['trillionaire'] = true;
        this.popup('ACHIEVEMENT UNLOCKED!', '<table><tr><td><img src="game/img/icons/icon_1.png"></td><td style="font-size:20px;">TRILLIONAIRE...</td></tr></table>', false, 4000);
    }
    
    this.player.client.emit('gameVars', {gameVars: gameVars, time : time});
}

exports.Game = Game;