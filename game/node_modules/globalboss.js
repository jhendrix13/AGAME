function globalBoss(funcs, clients, players, donors){
    //funcs module
    this.funcs = funcs;
    
    //all connected clients
    this.clients = clients;
    
    //in seconds
    this.timer = 600;
    
    //lobby variables
    this.lobbyWait = 60;
    this.lobbyStartTime;
    this.lobbyActive = false;
    
    //players
    //bad naming, I know!
    this.allPlayers = players;
    this.players = {};
    this.playerGameRefs = {};
    
    //boss
    this.matchTime = 60;
    this.matchStartTime;
    this.matchActive = false;
    
    this.bossNames = donors;
    
    this.boss = {
        'details' : {
            'name' : 'Global Boss',
            'startingHP' : 0,
            'hp' : 0
        }
    };
    
    this.countdownClock();
}

globalBoss.prototype.countdownClock = function(time){
    var self = this;
    
    if(typeof time == 'undefined')
        time = self.timer;
    
    this.countdown = setTimeout(function(){
        time--;
        
        self.sendTime(time);
        if(time <= 0){
            self.stopCountdownClock();
            self.lobby();
        }else{
            self.countdownClock(time);
        }
        
    }, 1000);
}

globalBoss.prototype.sendTime = function(time){
    this.clients.emit('globalBossCountdown', time);
}

globalBoss.prototype.stopCountdownClock = function(){
    clearTimeout(this.countdown);
}

globalBoss.prototype.lobby = function(){
    this.lobbyActive = true;
    this.lobbyStartTime = new Date().getTime();
    
    var self = this;
    this.lobbyTimer = setInterval(function(){
        var d = new Date().getTime();
        
        //yeah, send 'dem lobby details!
        self.emit('lobbyDetails', {
            players : self.players,
            lobbyCountdown : (self.lobbyWait-((d-self.lobbyStartTime)/1000))
        });
        
        //if lobby countdown completed
        if((d-self.lobbyStartTime)/1000 > self.lobbyWait){
            clearInterval(self.lobbyTimer);
            self.lobbyActive = false;
            self.startMatch();
        }
        
    },1000);
}

globalBoss.prototype.playerJoin = function(player, playerData, game){
    //don't let them join twice, herp!
    if(typeof this.players[player] == 'undefined'){
        this.players[player] = {
            'level' : playerData.level,
            'userid' : player,
            'username' : playerData.username,
            'damageDealt' : 0,
            'attacks' : 0,
            'lastAttack' : 0,
            'avatar' : game.player.avatar
        };
        
        //get their average attack, and times that by 20
        var avgDamage = game.getHitDamage(playerData.level)*30;
        
        //add this to the globalboss health
        this.boss.details.startingHP += avgDamage;
        this.boss.details.hp += avgDamage;
        
        this.playerGameRefs[player] = game;
        this.emit('lobbyPlayerJoined', playerData.username);
    }
}

globalBoss.prototype.playerLeave = function(player, username){
    if(typeof this.players[player] != 'undefined'){
        this.playerGameRefs[player].inLobby = false;
        
        delete this.players[player];
        delete this.playerGameRefs[player];
        
        this.emit('lobbyPlayerLeft', username);
    }
}

globalBoss.prototype.startMatch = function(){
    //set a random name from boss names
    if(this.bossNames.length  > 0)
        this.boss.details.name = this.bossNames[this.funcs.rand(0,this.bossNames.length)];
    
    //tell entire game a match has started
    this.clients.emit('matchBegin', {
        startingHP: this.boss.details.startingHP,
        name: this.boss.details.name,
        players : this.players
    });
    
    this.matchActive = true;
    this.matchStartTime = new Date().getTime();
    
    var self = this;
    this.matchInterval = setInterval(function(){
        var d = new Date().getTime();
        
        //if match is going
        if((d-self.matchStartTime)/1000 <= self.matchTime){
            self.emit('matchDetails', {
                boss : self.boss,
                timeRemaining : (self.matchTime-((d-self.matchStartTime)/1000))
            });
        }else{
            self.endMatch();
        }
    },1000);
}

globalBoss.prototype.attacked = function(player, damage, coords){
    var self = this;
    if(self.matchActive){
        var game = self.playerGameRefs[player];
        var details = self.players[player];
        var d = new Date().getTime();
//        
//        if((d-details.lastAttack) < 60){
//            game.popup('Hello Robot', 'You are clicking too fast. Let\'s NOT do that.', '', 0);
//            console.log(player + ' kicked for possible auto-clicking.');
//            self.playerLeave(player, game.player.username);
//        }else{
            console.log(player + ': '+ (d-details.lastAttack));
            self.boss.details.hp -= damage;
            details.damageDealt += damage;
            details.attacks++;
            details.lastAttack = d;
            
            game.player.client.emit('globalbossAttacked', {
                damage : damage,
                coords : coords
            });

            if(self.boss.details.hp <= 0)
                self.endMatch();
//        }
    }
}

globalBoss.prototype.endMatch = function(){
    var self = this;
    clearInterval(self.matchInterval);
            
    //reward will add the rewards received to each
    //players' object, so call self before we send the
    //the player data!
    self.reward();

    self.emit('matchEnd', {
        players : self.players
    });
    
    //change all "inLobby" statuses!
    for(var player in self.players)
        self.playerGameRefs[player].inLobby = false;
    
    
    self.matchActive = false;
    self.players = {};
    self.playerGameRefs = {};
    self.boss.details.hp = 0;
    self.boss.details.startingHP = 0;
    self.countdownClock();
}

//go through each player and give out rewards based on
//the amount of damaged they caused to the boss
globalBoss.prototype.reward = function(){
    var self = this;
    var dropTable = {
        'ring_of_efficiency' : 12,
        'godspear_fragment' : 30,
        'cheap_labor' : 12,
        'attack_boost' : 20,
        'speed_research' : 8,
        'diminishing_research' : 8,
        'double_exp' : 8
    };
    
    if(self.boss.details.hp <= 0){
        for(var player in self.players){
            var details = self.players[player];
            var game = self.playerGameRefs[player];
            var rewarded = false;
            
            if(details.attacks > 1)
                rewarded = true;
                
            if(rewarded){
                //boss currency!
                var bc = 150;
                game.player.gameVars.bossCurrency += bc;
                
                //exp!
                var exp = game.expEarnedBasedOnBF(game.player.gameVars.bossDifficulty);
                game.player.gameVars.exp += exp;
                
                //get drops!
                var drops = game.getDrops(dropTable);
                
                var drophtml = '';
                if(drops.length > 0){
                    for(var i = 0; i < drops.length; i++){
                        var iObj = game.player.resources.items.items[drops[i]];
                        drophtml += '<span class="popup_item"><b>'+ iObj.name +'</b><br/><img src="'+ iObj.img +'" /></span>';
                    }
                }else{
                    drophtml = '<br/>No items were dropped by the random boss.';
                }

                //give them the special worker if they did more than
                //1000 damage!
                if(details.damageDealt > 1000)
                    game.gbGiveMinion();
            }
            
            var html = 'You have successfully completed the event.<hr><table>';
                html += '<tr><td><b>Damage Dealt:</b></td><td>'+ game.funcs.numberFormat(details.damageDealt) +'<br/><br/></td></tr>';
                html += '<tr><td><span class="popup_rewardstitle">REWARDS</span></td></tr>';
                
                if(rewarded){
                    html += '<tr><td><b>Boss currency earned:</b></td><td>'+ game.funcs.numberFormat(bc) +'</td></tr>';
                    html += '<tr><td><b>Experience Gained:</b></td><td>'+ game.funcs.numberFormat(exp) +'</td></tr>';
                    html += '<tr><td colspan="2"><b>Items dropped</b></td></tr>';
                    html += '<tr><td style="width:100%;">'+ drophtml +'</td></tr>';
                }else{
                    html += '<tr><td>You did not contribute enough to this event, so you receive no rewards.</td></tr>';
                }
                
            game.popup('ACTIVITY PASSED!', html, '', 0);
        }
    }else{
        for(var player in self.players)
            self.playerGameRefs[player].popup('ACTIVITY FAILED!', 'Failed! The boss was not killed.', '', 0);
    }
}

//emit to players that are in the lobby or match only!
globalBoss.prototype.emit = function(var1, var2){
    var self = this;
    for(var player in self.players){
        var clientID = self.allPlayers[player].clientID;
        
        if(typeof self.clients.sockets[clientID] != 'undefined')
            self.clients.sockets[clientID].emit(var1, var2);
    }
}

//export class
exports.globalBoss = globalBoss;